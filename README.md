# Двусвязный-список 
## Методы

____

+ PUSH_BACK() 
#### Добавляет элемент в конец списка, сложность данного алгоритма o(1) - Проверяем если добавляемый элемент первый в списке то head и tail будут ссылться на первый элемент, иначе указатель (next) последнего узла(tail) будет ссылаться на новый узел, а указатель prev нового узла на узел tail, и в конце операцией присваивания tail передвигаем на новый узел, что бы tail обратно указывал на последний узел. И в конце увеличиваем размер списка.

+ PUSH_FRONT()
#### Добавляет элемент на начало списка, сложность данного алгоритма o(1) -  Проверяем если добавляемый элемент первый в списке то head и tail будут ссылться на первый элемент, иначе указатель (prev) первого элемента будет ссылаться на новый узел, а указатель (next) нового узла на первый элемент, и в конце операцией присваивания head передвигаем на новый узел, что бы head обратно указывал на первый узел. И в конце увеличиваем размер списка.

+ INSERT()
#### Добавляет элемент в произвольное место списка, сложность такого алгоритма o(n) - потому что нужно искать (left, right) узлы а сама вставка o(1), перед тем как добавить новый элемент, необходимо проверить индекс под новым узлом, так что бы она была в диапазоне (> 0 && < size - 1), иначе делаем исключение. Если индекс допустим, проверяем что если индекс равен нулю, то вызваем метод PUSH_FRONT(), иначе создаем новый узел, указателю (prev) нового узла инициализируем left (prev), a указателю (next) нового узла инициализируем left.next. И в конце увеличиваем размер списка.

+ POP_PACK()
#### Удаляет последний элемент в двусвязном списке, сложность такого алгоритма o(1) - потому что каждый узел хранит указатель на предыдущий  узел, в отличии от односвязного где такая операция была бы со сложность o(n). Если список пуст то нечего удалять, если всего одни елемент то его и удаляем, иначе tail передвигаем на tail (prev) а tail (next) указываем на nullptr. И в конце уменьшаем размер списка.

+ POP_FRONT()
#### Удаляет первый элемент в в двусвязном списке, сложность такого алгоритма o(1) - Если список пуст то нечего удалять, если всего одни елемент то его и удаляем, иначе head передвигаем на head (next) а head (prev) указываем на nullptr. И в конце уменьшаем размер списка.

+ REMOVE()
#### Удаляет элемент в произвольное место списка, сложность такого алгоритма o(n) - потому что нужно искать (left, right) узлы а сама вставка o(1), перед тем как добавить новый элемент, необходимо проверить индекс под новым узлом, так что бы она была в диапазоне (> 0 && < size - 1), иначе делаем исключение. Если индекс допустим, проверяем что если индекс равен нулю, то вызваем метод POP_FRONT(), если удаляемый элемент последний вызываем метод POP_BACK(), иначе left(next) инициализируем right, а right(prev) инициализируем left. И в конце уменьшаем размер списка.

+ GET_SIZE
#### Возвращает количество узлов.

+ GET_TAIL()
#### Возвращает указатель на tail.

+ GET_HEAD()
#### Возвращает указатель на head.



